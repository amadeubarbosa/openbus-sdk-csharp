\documentclass[12pt]{article}

%% Estilos e Plug-Ins
\usepackage{a4}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{color}
\usepackage{epsfig}
\usepackage{mwlabinputs}
\usepackage{hyperref}

\setlength{\parskip}{6mm}
\textheight=8.2in

%% Redefines the label 'Listing' to ..                                            
\def\lstlistingname{Código}                                                       
\lstset{inputencoding=latin1}                                                     
\codestyle{colorful}                                                              
%% Removes hyperlinks borders                                                     
\hypersetup{                                                                      
  pdfborder = {0 0 0},                                                            
}

\newcommand{\code}[1]{\texttt{#1}}

% ===================
% Definindo a linguagem CSharp
% ===================

\lstdefinelanguage{CSharp}
{
 morecomment = [l]{//}, 
 morecomment = [l]{///},
 morecomment = [s]{/*}{*/},
 morestring=[b]", 
 sensitive = true,
 morekeywords = {abstract,  event,  new,  struct,
   as,  explicit,  null,  switch,
   base,  extern,  object,  this,
   bool,  false,  operator,  throw,
   break,  finally,  out,  true,
   byte,  fixed,  override,  try,
   case,  float,  params,  typeof,
   catch,  for,  private,  uint,
   char,  foreach,  protected,  ulong,
   checked,  goto,  public,  unchecked,
   class,  if,  readonly,  unsafe,
   const,  implicit,  ref,  ushort,
   continue,  in,  return,  using,
   decimal,  int,  sbyte,  virtual,
   default,  interface,  sealed,  volatile,
   delegate,  internal,  short,  void,
   do,  is,  sizeof,  while,
   double,  lock,  stackalloc,   
   else,  long,  static,   
   enum,  namespace,  string}
}

% ===================
% Inicio do documento
% ===================

\begin{document} 

\title{OpenBus-CSharp - Tutorial - API}
\author{C. Augusto, R. Cosme, R. Cerqueira \\
        Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}

\date{}
\maketitle


\pagenumbering{arabic}

\section{Introdução}

Este documento é destinado aos usuários desenvolvedores de aplicações .NET que desejem utilizar o OpenBus. O processo de \emph{deployment} do barramento não é coberto neste tutorial. Considera-se como pré-requisito para um bom entendimento deste documento o conhecimento básico dos seguintes assuntos:

\begin{itemize}
	\item Linguagem de programação C\#.
	\item CORBA.
	\item Modelo de Componentes SCS.
	\item Conceitos básicos do Openbus.
\end{itemize}

\section{Preparação do Ambiente}

O OpenBus utiliza o mecanismo de interceptação de CORBA no processo de controle de acesso aos serviços. Após a chamada de requisição de \emph{login} no barramento, todas as chamadas seguintes devem estar com a credencial de acesso anexada. Sendo assim, faz-se necessário a habilitação dos interceptadores frente ao ORB que será utilizado. No OpenBus-C\# a comunicação será feira utilizando o IIOP.NET, e a API se encarregará de registrar os interceptadores em sua inicialização. Não sendo necessária nenhuma ação por parte do usuário nesse aspecto.
	
\subsection{Teste}

Antes de começar a programação, é aconselhável que o usuário coloque em funcionamento a demo Hello que acompanha o pacote. O correto funcionamento da demo elimina uma série de possíveis problemas que o desenvolvedor possa enfrentar durante o seu projeto, como por exemplo: problemas de comunicação com o barramento, serviços básicos não disponíveis e ausência de bibliotecas externas.
A API C\# possui apenas o lado cliente. Por conta disso, para executar o demo, é necessário que o barramento e um demo hello servidor esteja em operação. A demo pode ser executada seguindo os seguintes passos:

\begin{itemize}
  \item Entrar no diretório \$OPENBUS\_HOME/demo/hello/c\#/DemoHello\_Client/Properties/ e configurar a localização do barramento no arquivo DemoConfig.settings.
  \item Executar o processo cliente da classe \$OPENBUS\_HOME/demo/hello/c\#/DemoHello\_Client/src/HelloClient.cs. Após a execução do cliente, no terminal do processo servidor a seguinte mensagem deve ser exibida: "Hello !!!"
\end{itemize}

\section{Desenvolvimento}

\subsection{API}\label{api}

A API é composta pela classe Openbus e pelos \emph{stubs} do serviços básicos - Serviço de Controle de Acesso, Serviço de Registro e Serviço de Sessão. A classe Openbus atualmente é implementada como o padrão \emph{singleton}, pois suporta apenas um barramento. A API C\# só possui os facilitadores para auxiliar o cliente, ainda não disponibilizamos o Openbus-C\# para servidores. Para obter a instância do barramento e (re)inicializá-la, deve-se utilizar o Código~\ref{lst:barramento}.

\begin{labeledcode}[CSharp]{barramento}{Obtenção da Instância do Barramento}
using OpenbusAPI;

Openbus openbus = Openbus.GetInstance();

// host e porta apenas para fins de exemplo.
openbus.Init(hostName, hostPort);
\end{labeledcode}

Os outros métodos da API Openbus serão explicados em mais detalhes a seguir:

\begin{itemize}
  \item \code{Openbus GetInstance()}: Fornece a instancia do barramento.
  \item \code{void Init(...)}: Inicializa a biblioteca.
  \item \code{IRegistryService Connect(String user, String password}: Realiza uma tentativa de conexão com o barramento. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, duas exceções além das de CORBA podem ser lançadas:
    \subitem \code{ACSLoginFailureException}: O par nome de usuário e senha não foram validados.
    \subitem \code{ArgumentException}: Caso o método receba argumentos inválidos.
  \item \code{IRegistryService Connect(String name, RSACryptoServiceProvider privateKey, X509Certificate2 acsCertificate)}: Realiza uma tentativa de conexão com o barramento, utilizando o mecanismo de certificação para o processo de autenticação. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, três exceções além das de CORBA podem ser lançadas:
    \subitem \code{ACSLoginFailureException}: O certificado não foi validado.
    \subitem \code{InvalidCredentialException}: Caso a credencial seja rejeitada ao tentar obter o Serviço de Registro.
    \subitem \code{ArgumentException}: Caso o método receba argumentos inválidos.
  \item \code{IRegistryService Connect(Credential credential)}: Realiza uma tentativa de conexão ao barramento, a partir de uma credencial já existente. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, duas exceções além das de CORBA podem ser lançadas:
    \subitem \code{InvalidCredentialException}: Caso a credencial seja rejeitada ao tentar obter o Serviço de Registro.
    \subitem \code{ArgumentException}: Caso o método receba argumentos inválidos.
  \item \code{boolean Disconnect()}: Desfaz a conexão atual.
  \item \code{void Destroy()}: Finaliza a utilização do barramento.
  \item \code{void Run()}: \emph{Loop} que processa requisições remotas.
  \item \code{IAccessControlService GetAccessControlService()}: Fornece o \emph{stub} do Serviço de Controle de Acesso.
  \item \code{IRegistryService GetRegistryService()}: Fornece o \emph{stub} do Serviço de Registro.
  \item \code{ISessionService GetSessionService()}: Fornece o \emph{stub} do Serviço de Sessão.
  \item \code{Credential}: Fornece a credencial de identificação do usuário frente ao barramento.
  \item \code{Credential GetInterceptedCredential()}: Fornece a credencial interceptada pelo interceptador servidor. Esta operação somente deve ser chamada durante o tratamento de alguma requisição à aplicação do usuário.
  \item \code{void SetThreadCredential(Credential credential)}: Define uma credencial a ser utilizada no lugar da credencial corrente. Útil para fornecer uma credencial com o campo delegate preenchido.
  \item \code{void SetInterceptable(String iface, String method, boolean interceptable)}: Controla se o método deve ou não ser interceptado pelo servidor.
  \item \code{void SetLeaseExpiredCallback(LeaseExpiredCallback lec)}: Registra uma callback para a notificação de que o lease da credencial de identificação do usuário expirou.
  \item \code{boolean RemoveLeaseExpiredCallback(LeaseExpiredCallback lec)}: Remove uma callback previamente registrada para a notificação de lease expirado.
  \item \code{boolean IsConnected()}: Informa o estado de conexão com o barramento.
  \item \code{boolean IsInterceptable(String iface, String method)}: Indica se o método da interface deve ser interceptado.
\end{itemize}
	
A explicação dos métodos dos serviços básicos podem ser encontrados na documentação referente às idls.


\subsection{Primeiros Passos}

Basicamente há dois tipos de aplicações Openbus. Uma que oferta serviços e outra que consome serviços, sendo possível e natural uma aplicação híbrida que tanto oferte quanto consuma. Para ambos os tipos, existe uma certa dinâmica de programação já definida, e é justamente a explicitação dessa dinâmica que será o objetivo deste tópico.

Como facilitador, os processos serão demonstrados com base na demo Hello. De propósito, este é uma demo muito simplória, que é composto de um módulo cliente e de outro servidor. O servidor oferta um serviço do tipo Hello num determinado barramento, enquanto que o cliente procura por este serviço no barramento e o utiliza.

\subsubsection{Conexão com o Barramento}

O primeiro passo é firmar uma conexão autenticada com o barramento, o que é necessário tanto para o cliente como para o servidor. Para se concluir a conexão é preciso:

\begin{itemize}
  \item Adquirir a instância que representa o barramento.
  \item Inicializar a classe Openbus.
  \item Efetuar uma autenticação no barramento através de um dos métodos de conexão da API.
\end{itemize}

Existem três modos de autenticação frente ao barramento:

\begin{itemize}
  \item Par usuário e senha.
  \item Certificado digital.
  \item Utilização de uma credencial já existente e válida.
\end{itemize}

O primeiro é destinado normalmente aos clientes que estão acessando o barramento à procura de um serviço. O segundo é mais adequado ao processo servidor que registrará um determinado serviço no barramento. Já o terceiro é útil para aplicações que dependam de terceiros para realizar uma autenticação, ou seja, não tenham acesso a um par usuário/senha nem a um certificado, mas sim a um terceiro elemento que proveja uma credencial válida.

No caso da autenticação via certificado, o responsável pelo serviço deve encaminhar ao administrador do barramento o certificado do serviço, ou seja, um arquivo especial que contenha a chave pública do serviço, dentre outras informações pertinentes. O administrador deve fornecer o certificado do serviço de controle de acesso.

Um exemplo do código necessário para a conexão com o barramento pode ser visto no Código~\ref{lst:conexao}.

\begin{labeledcode}[CSharp]{conexao}{Conexão com o Barramento}
using OpenbusAPI;
using OpenbusAPI.Security;

Openbus openbus = Openbus.GetInstance();

// host e porta apenas para fins de exemplo.
openbus.Init(hostName, hostPort);

RSACryptoServiceProvider privateKey = Crypto.ReadPrivateKey("HelloService.key");
X509Certificate2 acsCertificate = 
    Crypto.ReadCertificate("AccessControlService.crt");

RegistryService registryService = 
    openbus.Connect("HelloService", privateKey, acsCertificate);

\end{labeledcode}

\subsubsection{Serviço de Registro}

Um serviço pode ser colocado no barramento através de uma oferta de serviço (\emph{ServiceOffer}), que é uma estrutura que representa o serviço através de uma lista de propriedades (\emph{properties}) e de uma referência a um componente (\emph{member}) SCS. As definições em IDL dessas estruturas podem ser vistas no Código~\ref{lst:offer}.


\begin{labeledcode}[idl]{offer}{Definições de Ofertas de Serviço}
typedef sequence<string> PropertyValue;
struct Property {
    string name;
    PropertyValue value;
};

typedef sequence<Property> PropertyList;

struct ServiceOffer {
    PropertyList properties;
    scs::core::IComponent member;
};
\end{labeledcode}

A lista de propriedades pode ser utilizada para adicionar características para o serviço, a fim de facilitar a identificação por parte dos clientes.
	
A arquitetura do Openbus é baseada no modelo de componentes SCS. Os serviços são de fato representados por componentes, que podem apresentar distintas facetas (interfaces). Sendo assim, o primeiro passo para o registro de um serviço é criar um componente que represente esse serviço. Maiores informações sobre a criação de componentes SCS podem ser obtidas nos tutoriais desse projeto.

Um serviço registrado no barramento deve ser descrito através de uma oferta de serviço, que é representada pela estrutura \emph{ServiceOffer}. Pendura-se nessa estrutura o serviço em si, que é representado através de um componente SCS e, opcionalmente, uma lista de propriedades referentes ao serviço. As propriedades devem ser descritas numa estrutura que representa uma lista.

\subsubsection{Processo Cliente}

Como o servidor, o cliente necessita se autenticar ao barramento. Portanto, os mesmos passos aplicados ao servidor para a autenticação devem ser repetidos, com exceção que o cliente geralmente se autentica através do mecanismo de usuário e senha, como no Código~\ref{lst:clientauth}.

\begin{labeledcode}[CSharp]{clientauth}{Autenticação da Aplicação Cliente}
// userLogin e userPassword são variáveis String contendo o 
// nome de usuário e senha.
IRegistryService registryService = openbus.Connect(userLogin, userPassword);
\end{labeledcode}

Após a conexão bem sucedida com o barramento, o próximo passo é obter o serviço desejado. Isso pode ser feito através de uma chamada ao método \emph{find()} do Serviço de Registro, que retorna uma lista de ofertas de serviço que implementam a faceta que o usuário deseja. Um exemplo pode ser conferido no Código~\ref{lst:clientsearch}.

\begin{labeledcode}[CSharp]{clientsearch}{Busca por Ofertas de Serviço}
// busca no barramento serviços que implementem uma faceta de nome IHello.
// uma lista de *ofertas de serviço* é retornada para o usuário.
string[] facets = new string[] { "IHello" };
ServiceOffer[] offers = registryService.find(facets);

if (offers.Length < 1) {
  Console.WriteLine("O serviço Hello não se encontra no barramento.");
  Environment.Exit(1);
}

// pegar a primeira oferta recebida
ServiceOffer serviceOffer = servicesOffers[0];
\end{labeledcode}

Como visto anteriormente, a oferta de serviço contém uma referência para um componente SCS ou, mais especificamente, para sua faceta IComponent. Como esse componente pode apresentar diversas facetas, o usuário deve obter a faceta que deseja utilizar. No exemplo há somente uma faceta além das facetas básicas do modelo SCS, chamada IHello. A faceta recebida na oferta, IComponent, oferece métodos (\emph{getFacet} e \emph{getFacetByName}) para que o usuário possa obter um objeto CORBA que represente a faceta desejada. De posse do objeto CORBA, o usuário deve efetuar um \emph{typecast} para mapeá-lo para a interface desejada e daí em diante o programador estará apto a utilizar essa faceta / serviço. Um exemplo pode ser visto no Código~\ref{lst:clientfacet}.

\begin{labeledcode}[CSharp]{clientfacet}{Acesso à Faceta Desejada}
// obtenção da faceta IHello
IComponent component = serviceOffer.member;
MarshalByRefObject helloObj = component.getFacetByName("IHello");
IHello hello = helloObj as IHello;

// utilização da faceta / serviço IHello
hello.sayHello();
\end{labeledcode}

Os códigos completos podem ser conferidos nas demos do projeto.

\end{document}
