%
%  SDK OpenBus 2.0 - C#
%
%  Created by Carlos Eduardo Lara Augusto on 2012-10-22.
%  Copyright (c) 2012 Tecgraf/PUC-Rio. All rights reserved.
%
\documentclass[]{article}

\usepackage{lmodern}
\usepackage[T1]{fontenc}

% Use utf-8 encoding for foreign characters
\usepackage[latin1]{inputenc}

\usepackage[brazil]{babel}

% Setup for fullpage use
\usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}

% Multipart figures
%\usepackage{subfigure}

% More symbols
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{latexsym}

\usepackage{hyperref}

% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{mwlabinputs2}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%% Redefines the label 'Listing' for ..
\def\lstlistingname{Código}
\codestyle{colorful}

% new commands
\newcommand{\foreign}[1]{\textit{#1}}
\newcommand{\term}[1]{\textit{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\openbus}{\textsc{OpenBus}}
\newcommand{\corba}{\textsc{CORBA}}
\newcommand{\orb}{\textsc{ORB}}
\newcommand{\scs}{\textsc{SCS}}
\newcommand{\assistant}{\textsc{Assistant}}
\newcommand{\version}{2.0.1}


%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

\title{Tutorial do SDK C\# \version{} do \openbus{}}
\author{Tecgraf}

\date{\today}

\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle

\tableofcontents

\section{Introdução}

Este documento é destinado aos usuários desenvolvedores de aplicações .NET que
 desejem utilizar o \openbus{}~\cite{web:OPENBUS}. O processo de \emph{deployment} do barramento não
 é coberto neste tutorial. Considera-se como pré-requisito para um bom
 entendimento deste documento o conhecimento básico dos seguintes assuntos:

\begin{itemize}
  \item Linguagem de programação C\#.
  \item \corba{}.
  \item Modelo de Componentes \scs{}.
  \item Conceitos básicos do \openbus{}.
\end{itemize}

A proposta do manual é capacitar o desenvolvedor, que atenda aos
pré-requisitos do documento, a escrever serviços para o barramento
\openbus{} dentro do escopo dessa API.


\section {Escopo}

Assistente, ou \assistant{}, é o nome que damos a uma abstração da biblioteca de acesso do
\openbus{}. Ela visa a facilitar os recursos mais utilizados pelos
clientes do barramento. Para atingir esse objetivo, o \assistant{} torna-se menos flexível que o
uso direto da API básica, mas atende a maioria dos casos de uso
envolvendo o barramento \openbus{}.


\subsection{Aplicações do \assistant{}}

As aplicações mais comuns, e as que são melhor implementadas usando
o \assistant{}, têm o seguinte em comum:

\begin{itemize}
  \item Comunica-se com um único barramento.
  \item Possui apenas uma autenticação no barramento.
\end{itemize}

Geralmente um aplicativo que se conecta ao barramento é um de dois
tipos, ou um híbrido:

\begin{itemize}
  \item Servidor.
  \item Cliente.
  \item Híbrido do dois.
\end{itemize}

Um servidor adiciona ofertas ao barramento, disponibilizando um ou
mais serviços através destas ofertas. Um cliente, por outro lado,
consulta o barramento por ofertas de serviços que deseja consumir.


\subsection{O que o \assistant{} não faz}

Por ser uma abstração mais simples e focada em um grupo de casos de
uso, naturalmente o \assistant{} não consegue resolver todos os
problemas que a API básica (em cima da qual ele é implementado),
consegue.

Portanto, os seguintes casos só conseguem ser implementados com o uso da
API básica:

\begin{itemize}
  \item A aplicação se comunica com mais de um barramento.
  \item São necessárias múltiplas autenticações com um ou mais barramentos.
\end{itemize}

O \assistant{} recebe as informações de autenticação (como usuário,
senha, chave privada, etc) em sua construção, assim
como outras informações necessárias para o uso de \corba{}.

Com essas informações ele se autentica ao barramento de forma assíncrona e 
mantém válida essa autenticação, renovando-a quando expirar. Também é refeita a autenticação se a
mesma ficar inválida por qualquer motivo, como por exemplo erros de rede temporários.

A construção do \assistant{} não implica que a autenticação já tenha ocorrido com sucesso.
Isso significa que métodos síncronos como "FindServices" podem falhar com a exceção NO\_PERMISSION\{NoLogin\} pelo
fato de a aplicação não estar ainda autenticada no barramento. No entanto, alguns mecanismos são oferecidos para
facilitar o tratamento desses erros, como veremos na próxima seção.


\subsection{Vantagens de se utilizar o \assistant{}}

Para as aplicações que estão no escopo do \assistant{}, o mesmo possui várias vantagens, dentre as principais:

\begin{itemize}
  \item Autenticação simplificada com o barramento.
  \item Tratamento automático de erros.
  \item Ofertas de serviços são mantidas, sendo refeitas automaticamente caso a autenticação mude.
\end{itemize}

Como foi dito anteriormente, a autenticação ocorre de forma
assíncrona. O mesmo ocorre com o registro de ofertas. Essa diferença
entre o \assistant{} e a API básica é crucial para entender as
vantagens de se usar o mesmo.

O registro de ofertas ocorre de forma assíncrona e, se por qualquer
motivo o registro se perder, como por perder a autenticação com o
barramento, o \assistant{} automaticamente faz um novo registro da
oferta. Assim, o usuário não precisa se preocupar com os vários casos
de erro que possam acontecer num sistema distribuido para garantir
que suas ofertas estarão sempre visíveis a outros serviços.

Métodos síncronos  da API do \assistant{}, como por exemplo a busca de ofertas que tem um valor de retorno, em geral contam com um 
parâmetro que indica quantas tentativas devem ser feitas, já para evitar que erros como NO\_PERMISSION\{NoLogin\} e outros precisem ser capturados.
É possivel ainda definir um parâmetro opcional do \assistant{} que informa o tempo de espera entre as tentativas.
Essas e outras funcionalidades serão explicadas com mais detalhes neste documento em seções posteriores.

Utilizando o \assistant{} precisamos nos preocupar apenas com o conceito da autenticação ao barramento, 
já que apenas um barramento é utilizado. Caso a API básica fosse utilizada, teríamos de nos preocupar ainda 
com o conceito de conexão ao barramento (para mais detalhes, consultar a documentação da API básica).


\section{Preparação do Ambiente}

O \openbus{} utiliza o mecanismo de interceptação de \corba{} no processo de controle
 de acesso aos serviços. Após a chamada de requisição de \emph{login} no
 barramento, todas as chamadas seguintes devem estar com a credencial de acesso
 anexada. Sendo assim, faz-se necessário a habilitação dos interceptadores
 frente ao \orb{} que será utilizado. No SDK C\# a comunicação será feita
 utilizando o IIOP.NET, e o SDK se encarregará de registrar os interceptadores
 em sua inicialização, não sendo necessária nenhuma ação por parte do usuário
 nesse aspecto.

\subsection{Teste}

Antes de começar a programação, é aconselhável que o usuário coloque em
 funcionamento a demo Hello que acompanha o pacote do \assistant{}. O correto funcionamento
 da demo elimina uma série de possíveis problemas que o desenvolvedor possa
 enfrentar durante o seu projeto, como por exemplo: problemas de comunicação
 com o barramento, serviços básicos não disponíveis e ausência de bibliotecas
 externas.

A demo Hello C\# do \assistant{} possui um executável servidor e outro cliente e pode ser executada de acordo com as instruções do arquivo README.txt que a acompanha.

Após a execução do cliente, no terminal do processo servidor a seguinte
 mensagem deve ser exibida: "Hello <nome-da-entidade-cliente>!"


\section{Desenvolvimento}

\subsection{API}\label{api}

Prover ou buscar serviços em um barramento \openbus{} usando o \assistant{} são tarefas bem
simples. Para isso, precisamos construir uma instância da classe
\assistant{} que nos proverá as funções necessárias para ofertar ou buscar
serviços no barramento.

Em C\# instancia-se a classe "tecgraf.openbus.assistant.AssistantImpl" da interface "tecgraf.openbus.assistant.Assistant".
Além dessa classe, a API do \assistant{} é composta pela classe utilitária e estática "tecgraf.openbus.assistant.Utils".

No caso de aplicações do tipo servidor, que recebam chamadas, pode ser necessário o uso de mais uma classe: "tecgraf.openbus.OpenBusContext". 
Em C\# essa classe é um \emph{singleton} pois ela representa o escopo das chamadas de um \orb{}, e o IIOP.NET não permite mais do que uma instância de \orb{}.
Através dela, será possível obter a identidade do cliente ou cadeia de clientes de uma chamada. Para obter a instância \emph{singleton} tanto do \orb{} como da classe "OpenBusContext",
devemos utilizar a classe estática "tecgraf.openbus.ORBInitializer". Essa classe é responsável por instanciar e configurar o \orb{} e o "OpenBusContext". No futuro, caso o IIOP.NET suporte 
mais de uma instância de \orb{}, essa classe terá mais funcionalidades e será mais semelhante ao seus pares em outras linguagens suportadas pelo \openbus{}.

Nas próximas seções veremos o uso dessas classes em mais detalhes.

\subsection{Primeiros Passos}

Basicamente há dois tipos de aplicações distribuídas. Uma que oferta serviços e outra
 que consome serviços, sendo possível e natural uma aplicação híbrida que tanto
 oferte quanto consuma. Para ambos os tipos, a API do assistente tenta facilitar toda funcionalidade comum ou \emph{boilerplate}.

O uso do Assistente será demonstrado com base na demo Hello do \assistant{}. Propositalmente esta é
 uma demo muito simplória, que é composta de um processo cliente e outro
 servidor. O servidor oferta um serviço do tipo "Hello" num determinado
 barramento, enquanto que o cliente procura por este serviço no barramento e o
 utiliza. Quando isso acontece, o servidor imprime na saída padrão a frase "Hello World!".
Posteriormente, alteraremos o exemplo para que imprima a frase "Hello <nome-da-entidade-cliente>!".

\subsubsection{Autenticação em um Barramento}

O primeiro passo de qualquer aplicação que utilize um barramento \openbus{} através do \assistant{} é se autenticar. Atualmente existem três modos de autenticação:

\begin{itemize}
  \item Par usuário e senha.
  \item Certificado digital.
  \item Utilização de autenticação compartilhada.
\end{itemize}

O primeiro é destinado normalmente a clientes que estejam acessando o barramento
 à procura de um serviço. O segundo é mais adequado a processos servidor que
 registrarão um determinado serviço no barramento. Já o terceiro é útil para
 aplicações que dependam de terceiros para realizar uma autenticação, ou seja,
 não tenham acesso a um par usuário/senha nem a um certificado, mas sim a um
 terceiro elemento que se responsabilize pela autenticação dessa entidade.

No caso da autenticação via certificado, o responsável pelo serviço deve previamente
 encaminhar ao administrador do barramento o certificado do serviço, ou seja,
 um arquivo especial que contenha a chave pública do serviço.

Um exemplo do código necessário para a autenticação em um barramento pode ser visto
 no Código~\ref{lst:autent}.

\begin{samplelisting}[language=Java]{autent}{Autenticação em um Barramento}
string host = args[0];
ushort port = Convert.ToUInt16(args[1]);
string entity = args[2];
PrivateKey privateKey = Crypto.ReadKeyFile(args[3]);

Assistant assistant = new AssistantImpl(host, port, new PrivateKeyProperties(entity, privateKey));
\end{samplelisting}

Note que são necessários três parâmetros obrigatórios:

\begin{itemize}
  \item host: Endereço do barramento.
  \item port: Porta do barramento.
  \item properties: Propriedades da instância do assistente, que incluem os dados de autenticação.
\end{itemize}

O parâmetro properties é uma variável que implemente a interface "tecgraf.openbus.assistant.AssistantProperties". 
A classe a ser instanciada depende do tipo de autenticação que se deseja. No servidor do exemplo utilizaremos
 a autenticação por certificado digital, e então escolheremos a classe "tecgraf.openbus.assistant.PrivateKeyProperties".

O construtor dessa classe espera dois parâmetros obrigatórios:

\begin{itemize}
  \item entity: Nome da entidade a ser autenticada ao barramento. Esse nome deve ser o nome que foi associado previamente ao certificado digital, junto ao administrador do barramento.
  \item privateKey: Chave privada associada ao certificado digital cadastrado no barramento.
\end{itemize}

Uma instância que implemente a interface "tecgraf.openbus.PrivateKey" deve ser construída através da classe utilitária "tecgraf.openbus.security.Crypto", que contém métodos para se obter uma chave privada através de uma sequência de \emph{bytes} ou de um arquivo.

Como vimos anteriormente, após a construção de "tecgraf.openbus.assistant.AssistantImpl", a autenticação não necessariamente já
terá ocorrido, pois a mesma é feita assincronamente e pode se repetir
indefinidamente, sem intervenção do usuário. O \assistant{} assume
que a aplicação pretende se manter autenticada por todo o tempo em que o
\assistant{} se mantiver vivo. Por isso, qualquer erro que
implique na perda de autenticação será tratado pelo \assistant{}, que tentará
se autenticar novamente até conseguir. Essa é uma das principais
vantagens de se usar o \assistant{}.


\subsubsection{Registro de Ofertas}

O propósito principal do \assistant{} para um servidor é o de
autenticar a um barramento \openbus{} e ofertar os serviços no Registro de Ofertas.

Um serviço pode ser ofertado no barramento através de uma lista de propriedades e de uma referência a um
 componente \scs{}. A lista de propriedades pode ser utilizada para adicionar características para
 o serviço, a fim de facilitar a identificação por parte dos clientes.

A arquitetura do Openbus é baseada no modelo de componentes \scs{}. Os serviços
 são de fato representados por componentes, que podem apresentar distintas
 facetas (interfaces). Sendo assim, o primeiro passo para o registro de um
 serviço é criar um componente que represente esse serviço. Maiores informações
 sobre a criação de componentes \scs{} podem ser obtidas nos tutoriais desse
 projeto. Um exemplo de criação de componente pode ser visto no Código~\ref{lst:component}.

\begin{samplelisting}[language=Java]{component}{Exemplo de criação de um componente \scs{}}
// Cria o componente que conterá as facetas do servidor
ComponentContext component = new DefaultComponentContext(new ComponentId("hello", 1, 0, 0, ".net"));

// Cria a faceta Hello para o componente.
// A classe HelloImpl deve ser implementada de acordo com a especificação do serviço Hello.
component.AddFacet("Hello", Repository.GetRepositoryID(typeof (Hello)), new HelloImpl());
\end{samplelisting}

A lista de propriedades referentes ao serviço deve ser descrita numa lista de estruturas do tipo "ServiceProperty". Um
 exemplo de registro de uma oferta pode ser conferido no Código~\ref{lst:registering}.

\begin{samplelisting}[language=Java]{registering}{Registro de uma Oferta de Serviço}
// Define propriedades para a oferta de serviço a ser registrada no barramento
IComponent ic = component.GetIComponent();
ServiceProperty[] properties = new[] { new ServiceProperty("offer.domain", "Demo Hello") };

// Usa o assistente do OpenBus para registrar a oferta.
assistant.RegisterService(ic, properties);
\end{samplelisting}

Para finalizar a implementação do nosso servidor, falta apenas implementarmos o serviço "Hello" de fato, representado pela classe "HelloImpl" em nosso exemplo.
Começaremos com uma implementação que apenas imprime localmente "Hello World!" para qualquer chamada recebida. O código pode ser visto no Código~\ref{lst:hello}.

\begin{samplelisting}[language=Java]{hello}{Implementação da faceta Hello}
  public class HelloImpl : MarshalByRefObject, Hello {
    public void sayHello() {
      Console.WriteLine("Hello World!");
    }
  }
\end{samplelisting}

É interessante (mas não obrigatório) que um \emph{ProcessExit} seja instalado
 para garantir o término correto das conexões do \orb{}. Um exemplo pode ser
 conferido nos Códigos ~\ref{lst:processExit} e ~\ref{lst:hookinstall}.

\begin{samplelisting}[language=Java]{processExit}{Exemplo de um \emph{ProcessExit}}
static void CurrentDomain_ProcessExit(object sender, EventArgs e) {
  // Nesse exemplo "assistant" deve ser considerada uma variável global
  assistant.Shutdown();
}
\end{samplelisting}

\begin{samplelisting}[language=Java]{hookinstall}{Instalação de um \emph{EventHandler}}
AppDomain.CurrentDomain.ProcessExit += new EventHandler(CurrentDomain_ProcessExit);
\end{samplelisting}

Um outro detalhe importante é que, devido à forma como objetos do tipo "MarshalByRefObject" podem definir sua política de "tempo de vida", os \emph{servants} podem ser coletados pelo coletor de lixo mesmo ainda estando ativos e aguardando por chamadas. Isso pode ocorrer, por exemplo, caso não haja chamadas por um tempo. Para evitar esse tipo de comportamento e manter os \emph{servants} ativos indefinidamente, é necessário sobrescrever o método "InitializeLifetimeService" que indica quando o objeto deve ser coletado, como descrito no Código~\ref{lst:lifetime}. Isso deve ser feito em cada \emph{servant} implementado.

\begin{samplelisting}[language=Java]{lifetime}{Implementação da faceta Hello sobrescrevendo o método InitializeLifetimeService}
  public class HelloImpl : MarshalByRefObject, Hello {
    ...

    public  override object InitializeLifetimeService() {
      return null;
    }
  }
\end{samplelisting}

Até este ponto, o servidor basicamente se autenticou ao barramento e registrou seu
 serviço "Hello". O último passo necessário para finalizar o código do servidor é
 habilitar o processo a escutar as requisições CORBA que serão
 direcionadas para o serviço ofertado, o que pode ser feito simplesmente mantendo a thread principal ativa (ou qualquer outra thread que não seja de \emph{background}) com um Thread.Sleep(Timeout.Infinite).

\subsubsection{Processo Cliente}

Com o servidor pronto, é necessário agora construir um
consumidor deste serviço. Alguém que irá buscar o serviço no
Registro de Ofertas e chamar "sayHello()", que é o que o nosso serviço
atualmente faz.

Para tal precisamos, assim como no servidor, autenticarmo-nos ao
barramento. Porém, as coincidências acabam aí. No cliente não
criaremos \emph{servants} nem criaremos ofertas, apenas faremos uma
busca e, de posse da oferta, a utilizaremos.

Vejamos novamente a autenticação, mas desta vez de nosso cliente, no Código~\ref{lst:clientauth}.

\begin{samplelisting}[language=Java]{clientauth}{Autenticação da Aplicação Cliente}
string host = args[0];
ushort port = Convert.ToUInt16(args[1]);
string entity = args[2];
byte[] password = new ASCIIEncoding().GetBytes(args[3]);

Assistant assistant = new AssistantImpl(host, port, new PasswordProperties(entity, password));
\end{samplelisting}

Como vimos, a instanciação da classe "tecgraf.openbus.assistant.AssistantImpl"
coloca o \assistant{} em responsabilidade por nos autenticar ao
barramento de forma assíncrona. Agora, nos resta fazer uso do Registro
de Ofertas através dele. Para fazermos uma busca no
barramento por serviços, utilizamos o método "FindServices".

Para podermos fazer a busca, precisamos saber o que
buscar. Sabemos que nosso serviço possui uma faceta chamada "Hello", e
que o mesmo se autenticou no barramento com um nome de entidade específico. De posse dessas
informações, podemos usar um método utilitário do \assistant{} que
constrói uma lista de propriedades com essas duas propriedades. O nome
desse método é "CreateFacetAndEntityProperties", da classe estática "tecgraf.openbus.assistant.Utils". De posse dessa
lista de propriedades, podemos realizar a busca. Um exemplo pode ser conferido no
 Código~\ref{lst:clientsearch}. Opcionalmente, o método utilitário FilterWorkingOffers pode ser utilizado para a remoção de ofertas inválidas no momento de sua chamada.

\begin{samplelisting}[language=Java]{clientsearch}{Busca por Ofertas de Serviço}
ServiceProperty[] properties = assistant.CreateFacetAndEntityProperties(
  "nome-da-entidade-do-servidor", "Hello");
ServiceOfferDesc[] offers = Utils.FilterWorkingOffers(assistant.FindServices(properties, -1));
\end{samplelisting}

O método "FindServices" de busca de serviços recebe dois parâmetros:
uma lista de propriedades, que construímos com o método
"CreateFacetAndEntityProperties", e um inteiro que representa o número
de re-tentativas que a função deve fazer em caso de erros. Esse número
pode ser "-1", que indica que a função deve tentar indefinidamente;
pode ser o número "0", que indica que a função deve retornar uma
exceção se qualquer falha ocorrer e nenhuma nova tentativa se a mesma
falhar; e qualquer número maior que zero, que indica o número de novas
tentativas em caso de falhas. Caso o número de re-tentativas se esgote, a última
exceção recebida será lançada.

Como visto anteriormente, a oferta de serviço contém uma referência para um
 componente \scs{} ou, mais especificamente, para sua faceta "IComponent". Como esse
 componente pode apresentar diversas facetas, o usuário deve obter a faceta que
 deseja utilizar. No exemplo há somente uma faceta além das facetas básicas do
 modelo \scs{}, chamada "Hello". A faceta recebida na oferta, "IComponent", oferece os
 métodos (\emph{getFacet} e \emph{getFacetByName}) para que o usuário possa
 obter um objeto \corba{} que represente a faceta desejada. De posse do objeto
 \corba{}, o usuário deve efetuar um \emph{typecast} para mapeá-lo para a interface
 desejada e, daí em diante, o programador estará apto a utilizar essa
 faceta/serviço.

É importante notar que, apesar do \assistant{} ajudar no tratamento de erros das funcionalidades mais comuns,
a aplicação deve tratar por conta própria os erros que podem ocorrer ao realizar chamadas \corba{} diretamente
a um objeto remoto. As chamadas "getFacet" (ou "getFacetByName") e "sayHello" se enquadram nesse caso, portanto
precisam do tratamento adequado. Como a operação precisa
coordenar programas diferentes, rodando em arquiteturas e localidades
diferentes, inúmeras falhas são possíveis, sendo as mais comuns uma
falha de comunicação física como por exemplo o cabo de rede
desconectado. O serviço pode também não estar mais funcionando corretamente, ou ter sido
fechado.

Portanto, toda chamada remota deve estar protegida, de
algum modo, por tratamentos de erros. O tratamento de erro em \corba{}
é feito através de exceções. A exceção "omg.org.CORBA.TRANSIENT" significa
que o serviço não conseguiu se comunicar com o outro ponto; esse erro não indica uma falha definitiva. 
"omg.org.CORBA.COMM\_FAILURE" significa que a comunicação chegou ao outro lado mas, por algum motivo,
foi interrompida; por exemplo, uma falta de recurso. Já "omg.org.CORBA.OBJECT\_NOT\_EXIST" 
significa que o serviço que deveria prover
esse objeto \corba{} não possui esse objeto em sua memória, e
a sua referência deve ser descartada. Outras exceções de CORBA existem e todas herdam de
"omg.org.CORBA.AbstractCORBASystemException". Já exceções definidas pelo usuário em IDL herdam de  "Ch.Elca.Iiop.AbstractUserException".
Devido a detalhes da implementação do IIOP.NET, relacionados ao uso de reflexão no .NET, algumas exceções geradas pelo SDK OpenBus podem ser encapsuladas na exceção "System.Reflection.TargetInvocationException". Portanto, esse caso também deve ser tratado. No futuro, pretendemos alterar o IIOP.NET para que isso não seja mais necessário.
Um exemplo do tratamento de erros adequado pode ser visto no Código~\ref{lst:clientfacet}.

\begin{samplelisting}[language=Java]{clientfacet}{Acesso à Faceta Desejada}
string helloIDLType = Repository.GetRepositoryID(typeof (Hello));
bool failed = true;
if (offers != null) {
  if (offers.Length < 1) {
    Console.WriteLine("O serviço não se encontra no barramento.");
  }
  else {
    if (offers.Length > 1) {
      Console.WriteLine("Existe mais de um serviço no barramento. Tentaremos encontrar um funcional.");
    }
    foreach (ServiceOfferDesc serviceOfferDesc in offers) {
      Console.WriteLine("Testando uma das ofertas recebidas...");
      try {
        MarshalByRefObject helloObj =
          serviceOfferDesc.service_ref.getFacet(helloIDLType);
        if (helloObj == null) {
          Console.WriteLine("Não foi possível encontrar uma faceta da interface esperada na oferta.");
          continue;
        }
        Hello hello = helloObj as Hello;
        if (hello == null) {
          Console.WriteLine("A faceta encontrada na oferta não implementa a interface esperada.");
          continue;
        }
        Console.WriteLine("Foi encontrada uma oferta com um serviço funcional.");
        // utiliza o serviço
        hello.sayHello();
        failed = false;
        break;
      }
      catch (TRANSIENT) {
        Console.WriteLine("O serviço está inacessível.");
      }
      catch (COMM_FAILURE) {
        Console.WriteLine("Falha de comunicação ao acessar o serviço.");
      }
      catch (Exception e) {
        NO_PERMISSION npe = null;
        if (e is TargetInvocationException){
          // caso seja uma exceção lançada pelo SDK, será uma NO_PERMISSION
          npe = e.InnerException as NO_PERMISSION;
        }
        if ((npe == null) && (!(e is NO_PERMISSION))){
          // caso não seja uma NO_PERMISSION não é uma exceção esperada então deixamos passar.
          throw;
        }
        npe = npe ?? e as NO_PERMISSION;
        bool found = false;
        string message = String.Empty;
        switch (npe.Minor) {
          case NoLoginCode.ConstVal:
            message = "Não há um login válido no momento para a entidade utilizada.";
            found = true;
            break;
          case UnknownBusCode.ConstVal:
            message = "O serviço sendo utilizado não está mais autenticado no barramento.";
            found = true;
            break;
          case UnverifiedLoginCode.ConstVal:
            message = "O serviço sendo utilizado não foi capaz de validar a chamada.";
            found = true;
            break;
          case InvalidRemoteCode.ConstVal:
            message = "A integração do serviço sendo utilizado com o barramento está incorreta.";
            found = true;
            break;
        }
        if (found) {
          Console.WriteLine(message);
        }
        else {
          throw;
        }
      }
    }
    if (failed) {
      Console.WriteLine("Não foi encontrada uma oferta com um serviço funcional.");
    }
  }
}
\end{samplelisting}

Por fim, podemos finalizar o \assistant{} para que seja feito o \emph{logout} no barramento, como exemplificado no Código~\ref{lst:logout}.

\begin{samplelisting}[language=Java]{logout}{Finalizando o \assistant{}}
assistant.Shutdown();
\end{samplelisting}

Nesse ponto, podemos executar o servidor e em seguida o cliente. Assim que o cliente realizar a chamada sayHello, o servidor imprimirá na tela a mensagem "Hello World!".

\subsubsection{Acessando a cadeia de chamadas para identificar o cliente}

A maior evolução no barramento \openbus{} na versão 2.0 foi a
reformulação do sistema de segurança. Com este novo sistema, é possível para um serviço saber
qual a entidade que fez a chamada, e também é possível para algum
serviço intermediário passar para um serviço do qual ele é cliente a
identidade de quem está usando esse intermediário. Isso cria uma
cadeia de entidades que pode ser lida pelo serviço final para
autorizar ou não a chamada.

Veremos o caso mais simples, modificando o serviço "Hello" que
implementamos anteriormente para imprimir a mensagem "Hello <nome-da-entidade-cliente>!" ao invés de "Hello World!". 
Uma aplicação mais complexa poderia usar essa informação para escolher de qual banco de
dados pegaria os dados, ou como faria a autenticação para obter os
dados ou simplesmente recusar a operação para determinadas entidades.

Relembrando, nosso \emph{servant} "Hello" foi implementado como descrito no Código~\ref{lst:hello}.

Os métodos relativos a cadeias ficam na classe "OpenBusContext", como mencionado anteriormente. São eles:
"CallerChain", "JoinChain", "ExitChain" e "JoinedChain".

Faremos uso do método acessor "CallerChain", que retorna a cadeia de chamadas relativa à chamada atual. 
Como a implementação da classe "OpenBusContext" em C\# é um \emph{singleton}, podemos acessar sua instância facilmente,
e fazer a chamada a "CallerChain" em "sayHello". Um exemplo pode ser visto no Código~\ref{lst:chain}

\begin{samplelisting}[language=Java]{chain}{Acessando a cadeia relativa a uma chamada}
      Console.WriteLine(String.Format("Hello {0}!", ORBInitializer.Context.CallerChain.Caller.entity));
\end{samplelisting}

Desta forma implementamos um serviço que imprime o nome da entidade que
fez a chamada remota para nosso serviço. O código completo pode ser conferido na demo Hello do \assistant{}.


\subsection{Configurações avançadas}

\subsubsection{Definindo os níveis de log da API}

A API utiliza o log provido pela Apache (log4Net). A configuração do log4Net pode ser feita num arquivo xml que deve ter o nome
 OpenBus.config e estar no mesmo diretório da biblioteca. Caso nenhuma configuração
 seja fornecida, a biblioteca utilizará a configuração padrão que não utiliza log.

\subsubsection{Definindo as propriedades opcionais do Assistente}

Ao instanciar o \assistant{}, como vimos anteriormente, devemos passar um objeto que implemente a interface "tecgraf.openbus.assistant.AssistantProperties".
Essa interface fornece uma série de campos opcionais que podem ser modificados antes da instanciação do \assistant{}. São eles:

\begin{itemize}
  \item Interval: Intervalo de tempo a ser utilizado entre as re-tentativas de chamadas feitas pelo \assistant{}, sincronamente ou assincronamente.
  \item ORB: Acessor que funciona apenas como um \emph{getter}. Retorna a instância de \orb{} utilizada pelo \assistant{}, que é sempre a mesma, por ser um \emph{singleton}.
  \item ConnectionProperties: Propriedades opcionais da conexão utilizada internamente. Para mais detalhes, consulte a documentação da API básica.
  \item Type: Acessor que funciona apenas como um \emph{getter}. Retorna o tipo (enum "LoginType") de autenticação utilizado, definido através da escolha da classe instanciada (exemplo: "PasswordProperties" definirá o tipo como "LoginType.Password").
  \item LoginFailureCallback: método do tipo \emph{delegate} a ser chamado em caso de erros no processo de \emph{login}. A cada tentativa mal-sucedida, esse método será chamado. Um exemplo de uso é para \emph{logs}.
  \item RegisterFailureCallback: método do tipo \emph{delegate} a ser chamado em caso de erros no processo de registro de oferta. A cada tentativa mal-sucedida, esse método será chamado. Um exemplo de uso é para \emph{logs}.
  \item RemoveOfferFailureCallback: método do tipo \emph{delegate} a ser chamado em caso de erros no processo de remoção de ofertas. A cada tentativa mal-sucedida, esse método será chamado. Um exemplo de uso é para \emph{logs}.
  \item FindFailureCallback: método do tipo \emph{delegate} a ser chamado em caso de erros no processo de busca de ofertas. A cada tentativa mal-sucedida, esse método será chamado. Um exemplo de uso é para \emph{logs}.
  \item StartSharedAuthFailureCallback: método do tipo \emph{delegate} a ser chamado em caso de erros no processo de \emph{login} por autenticação compartilhada. A cada tentativa mal-sucedida, esse método será chamado. Um exemplo de uso é para \emph{logs}.
\end{itemize}

\include{glossary}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
